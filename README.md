# 0829 

# Unlucky 7  diff 131

解答遷移  AC

問題把握 00:13  発想 00:00   base 04:30  デバック&提出 02:05

備考

➀ 8進数

整数Nの8進数文字列は f"{N:o}"で出力可能




# 185C Duodecim Ferra diff 374　

解答遷移 WA 諦め(再解答の必要はなし)

問題把握 01:42  発想 + base 08:18  計 21:14 諦め


備考

➀ scipy.special 整数型

![image](https://user-images.githubusercontent.com/109026838/187097939-c96a938b-fa12-4ad8-8ab6-90d48c2a0c79.png)

int(comb((L-1),11))としたためにL=200などの大きな値の処理が正確出来なかった。

3つだけWAが発生してコーナーケースを考えたが存在しないと結論付けた。そこで上限値でなにか問題が発生しているのかなと考えたはしたのだが、その場合はどうせ解けないなとcombの仕様を調べようともせずににすぐ諦めてしまった。仕様を知らなかったことは仕方ないが、この努力をできなかったことを大きく反省する。


# ABC171D Replacing    diff 498

解答遷移 AC

問題把握 01:13  発想 01:31  base 04:48  デバック&提出 05:12  計 12:46

備考

なし



# 258C Rotation  2回目   diff 419    類題 199C

解答遷移 AC

問題把握 01:22  発想 11:08  base 03:16  デバック&提出 01:04　計 16:52


備考

➀ 思考

クエリ1で本当に入替を行うのは無理だから疑似いれかえをしたいな →  最初のindex番号をキーに、要素をvalueにした辞書を作ることを考えたが、キーを変化させるにはループが必要になるからこれじゃだめだな。→ 結構時間をかけて考えた後、クエリ２で取り出す場所の方をいれかえを反映させた数字にすればよいこと気付いてACできた





# 187C 1-SAT   diff 207

解答遷移 AC

問題把握 02:01  発想 09:15  base 06:02  デバック&提出 12:24  計 29:43


備考

➀ 速度ボトルネック

題意読み取りミスが原因。Sを揃えてから存在確認の判定を必要があることになかなか気づかなかった。

また解法もナンセンス

そもそも調べる文字列が"!"つきか否か分類する必要がない。例えば red は red , !red を調べるのに対して、!red なら !red , !!red であるため、なにか特別な処理を施さなくても自然に異っていて条件で区別する必要がないことを読み取れななかった。



* この読み取りミスの原因は部分的な処理に頭を使ってしまうこと？

今回では!をうまく処理するためにpopがいけるかどうかみたいなことに9割思考を割いてしまうせいで、やらなければいけないことが曖昧なまま方針を進めたり、コードを書いてしまうことが原因かもしれない。速度ガ大切なため完全に整理してから進めるのは不可能だが、全体を俯瞰する姿勢をとる必要がありそう。



# 265C  Comma   diff 265

解答遷移 AC

問題把握 00:40  発想 05:44  base 05:44  デバック&提出 02:57  計 15:07  

備考

➀ 速度ボトルネック

N < 10^s における探索時の個数処理の正確さが不安で確認を慎重に行ったために作成時に時間がかかってしまった。N+1<=10^sなのだからどんなNであってもmin処理の結果が同じことが時間をかけないとわからなかった。


➁　別解(模範解答)

その数に何個のカンマがあるのかに注目する自分の解答とは異なり、その数に特定の位置のカンマが存在するかに注目することもできる。例えばN=7,777,777の場合、3-4桁目,6-7桁目のカンマは存在するが、9-10桁目,12-15桁目,18-19桁目のカンマは存在しない。よって+2のように考えることも可能。





# 0831 

# 176C Step  diff  72

解答遷移 AC

問題把握 00:21  base 04:21  デバック&提出 01:35  計 06:18

備考

なし


# 209C  Not Equal  diff 285 

解答遷移 AC

発想まで?  11:44   baseから提出まで? 05:23   計 17:07  (境界が曖昧)

備考

➀ 思考

素直に実装すると、Cの要素を前から探索して、その要素の値以下の数値を探索していくことになるがそれは無理だな。　→ 逆にどんな数値かを探索して、setで重複処理すればいけるか？ でも、Aが数値ではないので探索ができない  

Cの制約的に探索するのかと思ったが、思いつく限りの探索方法を講じても制約を突破できないので何か直接答え出力する方法がないか探してみる。 → sortして前から順に、i番目に(要素-i)の値をかけていく処理をすればよいことに気づいてAC


とても速い提出とはいえないが、プロセス自体は良いと思うので、あとは自分自身の思考処理がはやくなれば完璧





# 189C Mandarin Orange  diff 565

解答遷移  AC

問題把握 02:38  発想 18:44  base 03:30  デバック&提出 00:52  計 25:46

備考

➀思考

前から探索しても、区間を探索できないから組み合わえ使うか？ でも5.0 * 10^7で無理ではないが他のより高速な処理を探そう　→ 探索開始位置と終了位置を二重ループで操作するのはどうか？　これも結局同じか　

setならmin処理が速いか調べたりしながら、ここでようやく区間の始点終点を決めても取り出すのにO(l)かかるからこれじゃだめなことに気づく。

発想を変えてAの要素で探索しようとしたところ 5.0 * 10^7にはなるがこれで解答は一応できることがわかったので、ほかに案もないしダメもとで出したらACできた。


➁模範解答

よく考えたら区間をとりだす必要はなく、その区間での最小値さえわかればよいので自分が捨てた方針でACできる。ただしmin処理に注意

➁ pypy 

➀でも記述したが、5.0 * 10^7 ならpypyで通る






#  0901  

# 176B Multiple of 9     diff  51

解答遷移 AC

問題把握 00:45  base 01:06  デバック&提出 00:41  計 02:33

備考

なし


# 177B Substring     diff  193

解答遷移 AC

備考　

なし



# 166C Peak   diff 263

解答遷移 AC

計 24:21

備考

➀　思考と計算量

各展望台について隣接する展望台のリストを作ってその最大値をmaxで取得する場合、O(N^2)になるためこれではだめだなと思って、熟考し最大値のみを保有することでO(N)の解答を導くことができた。

しかし、却下した方針でも普通にACできた。これは、ある展望台については他全ての展望台と隣接することはあっても、隣接候補が2M個しかないために探索回数はO(N^2)ではなくO(2M)になるからだと思われる。




#  Alter Altar     diff  486

解答遷移 AC

問題把握  04:07  発想 24:27   提出まで 02:32  計  31:56


備考

➀ 思考

1,アルゴリズム理解 09:49  + 2,コードでどう実装するかの思考 15:27  の計24:27を発想段階で費やした。(少しコードも書いてはいるがほぼ思考時間)


とりあえずシミレーション。入替と色変えの効率を比べたりしながら、石の入れ替え位置候補が多すぎてこれを探索することは不可能だと感じ、操作完了時の石の状態に注目してみた。すると最も右の位置にある赤石と最も左の位置にある白石が...w...R...のように白 < 赤になっている場合にはまだ操作が必要で、そうでないなら操作完了になるなと気が付く　 1  → 白石と赤石の位置を調べあげ、初めて白 > 赤　になるindex回操作が必要である処理でAC 2




# 196B  Round Down   diff 39

解答遷移 AC

問題把握 00:13    提出まで 03:31   計 03:45   

備考

➀ 思考

floatで受け取って、math.floorすればいいや。→ sample3で、入力を受け取った時点で小数16桁付近から情報が落ちていることを確認。仕方なく文字列として受け取り前から "." まで探索し出力する方針でAC

割算演算の結果のみでなく、入力時点でも情報が落ちてしまうことに気を付ける




# 0902

# uNrEaDaBlE sTrInG   diff  23

解答遷移 AC

計 04:18

備考

➀ 小文字 / 大文字判定

文字列.islower() /  .isupper()にて文字列が全て小文字か大文字かを判定できる



# Unexpressed   diff 379

解答遷移 WA  WA  AC

問題把握 00:49   発想  02:49   base  03:40   初提出までのデバック  12:36   AC 08:17   計 28:12 +10:00


備考

➀　注意点

1, 重複処理

たとえば 16　のような 2^4　とも 4^2 とも表現できる数字のカウントを正確に行わなくてはいけない

2, break処理

a^2 > N となった場合、(a+1) ^2 >Nなので処理をうち切りたい。b=2のまま処理が終了したことを表すflagを使ってprintする処理を実装した場合、ループ回数が十分に大きくないと10^10の場合にprintされないことになる。詳しくはコード参照




# ☆ 226D Teleportation     diff 706

平行な場合にも同じ魔法であることを処理できず諦め

問題把握 04:14  発想 29:13  base 11:55  　計 1:04:32


備考

➀ 傾きと最大公約数

2点間の変化量を表す傾き dy/dxを素直に実装すると割算になって不便であることは　226C(0820) でも学んだが、dxとdyの最大公約数gによって(dx/g,dy/g)により、その傾きを代表するベクトルを表現できる。

なお、a,bの最大公約数はmath.gcd(a,b)にて O(log(max(a,b))で出力可能


➁ hash化　タプルとリスト

辞書のキーやsetの要素にリストは渡せないが、タプルなら可能


③ 解答補足

combinationsを使っ探索し結果を2倍する処理では正解できない。なぜなら傾きの絶対値が同じ2点であってもベクトルが違えば傾きが変化しsetにどちらも格納されることになってしまうからである



#  148C  Snack

解答遷移 AC

計 05:35

備考

➀　最小公倍数

a,bの最小公倍数は　a * b // gcd(a,b)  で求められる





# 224C Triangle? 2回目

解答遷移  RE ➁ / TLE ③ / AC ➀

計 27:15 + 10:00

備考

➀　最大公約数解法

226Dで傾きを最大公約数で解釈できるようになったので練習がてらこの問題を最大公約数を利用して解いてみた。この問題では選んだ3点において、同一直線状にあっても始点の決め方でベクトルの向きが変ってしまうこと、にさえ気を付ければこの解法でもACすることができた。

ただし模範解答の、傾き分母払い解法であれば逆ベクトルを考える必要がないためこちらの方が楽である。


➁scipy と pypy

pypypではnumpy 同様にscipyも扱えない。そのためこの問題をpypyで通したいなら、N* (N-1)* (N-2)//6とするしかない

③ 計算量

NC3 * log(max(dx,dy)) はx,y <= 10^9　により 10^8近くなる。そのためpythonで最大公約数解法は使えない



# 0903

# 048A A to Z String   diff 54

解答遷移  AC

計 01:59

備考

なし


# 053B A to Z String  diff 164

解答遷移  AC

計 07:33

備考

➀　解法

読み違えたままACしてしまったが、この問題ではZが来ても数をリセットするのではなく、最左のAの位置と最右のZの位置が分かればよい問題である




# 連結リスト Linked List 勉強

ノードのつながりを記憶するデータ構造。インスタンスにその前後のインスタンスを記憶させて、挿入をくりかえすことで一つの連結リストを作成する

・ LikedList インスタンス式

https://www.delftstack.com/ja/howto/python/linked-list-in-python/

ノードの挿入などの関数を持つ全体のクラスを作成し、これを操作してノードインスタンスを連結させる方法

・アルゴ式

https://algo-method.com/tasks/844/editorial

最初と最後のノードnilを作り、nilを目印にして連結する方法


・欠点

abc225(後述) に顕著であるが、特定の位置にアクセスすることができない。前から辿って見つける必要がある。

https://www.momoyama-usagi.com/entry/info-algo-list#i-2





# ☆ abc225D  Play Train   diff  778

方針がたたず諦め

備考

➀ 双方向連結リスト

上述した連結リストの考えで解答可能。ただし生成される連結リストが一つではない点、アクセスが不便な点からTrainクラスの連結でこの問題を解くことは難しい。

そこでリストのtrain番号に対応した場所にその電車の前にある電車と後ろにある電車の情報を格納したリストを格納することで操作1,2をO(1)で処理することができる。もしくは前の電車の情報と後ろの電車の情報をそれぞれ別のリストにわけて記憶することでも解答可能




# ☆ 181D Hachi    diff  600

解法がわからず諦め

備考

➀　思考

並び替えの探索は不可能なのでそれ以外の方針をとるべきだとは思ったものの、8進数や他の方針を考え始めて、しまいには8の倍数の判定方法を調べることもせずあきらめてしまった。

８の倍数を列挙して4の倍数の様に下2桁に注目して8の倍数以外もあるなと最初に気づき、そこでこの方針はだめだと打ち切ったことを引き釣り判定方法わからないと結論付けて調べようともしないこの姿勢がダメ


➁ 8の倍数

1000 = 125 * 8 であることに注目すると、例えば 5424 → 5* 1000^1  + 424 * 1000^0 より 424 が8の倍数であることと、5424が8の倍数であることの真偽は一致する




#  180A  box  

解答遷移 AC

備考

なし


#  180B Various distances   diff 129

解答遷移 AC

備考

なし



# ☆　211C  chokudai  diff 559

解答遷移 TLE 諦め

備考

➀ 思考

chokudaiを構成する8文字のそえぞれがSに出てくる場所さえわかれば、cから順に次の文字を二分探索すれば、例えば8文字すべてに10^5 /8 個登場するとしても 10^5 / 8 * 10g(10^5 / 8)^8 で間に合うと思った。

しかし実際に実装してみると次の文字の中でもある文字を動かす必要があり結局これではループが8重になりTLEすることに気づいた。

かなり時間を使ってようやくdpっぽく処理できるなと気づき導入。chokudaiリストと同じ形状のdpを作って、dp[n][m]を文字nの中のm番目のものを使ってchokudaiのnの文字までの組み方の数を表して、nのm番目とn+1のm`番目を比較してm<m`ならばdp[i+1][m`]+=dp[i][m]とすればよいと考えた。　→ しかしこれでは8つの文字それぞれにおいて前から順に探索が必要な点が解消されていないのでACできずTLEしてしまった


➁　模範解答

dp

Sに出てくるn番目の文字でchokudaiのある場所までを表現することができる総数に注目する。例えばn番目がkならn-1番目までで作ったoまでの文字列が新たにkまで構成できるようになるのでdp[n][kを表すindexl+=dp[n-1][kを表すindex]+dp[n-1][oを表すindex]  * が成り立つ

またcにおいては前の文字がなく、dp[n][cを表すindex]=dp[n-1][cを表すindex]+1となるが、すべての要素が1の-1列目をdpに追加すれば他の処理と同じく * 式で済む

また、実はdpでは直前の情報以外使用しないので、すべての情報を記憶する意味はない。よって9列の一次元リストを作成し、S[i]がchokudaiを構成するならばdp[S[i]の表すindex+1] = dp[S[i]を表すindex]として古い情報を更新してしまうことも可能




# 0905

# Changing Jewels   diff  413　　2回目

解答遷移  AC

計 09:47

備考

➀ dpで解答



# アルゴ式 dp基礎編

# 3-2 部分和問題

解答遷移 AC

計 25:00

備考

➀ 思考

2^100は探索できない。M以下の最大値を保存していてもW1+WN=Mだった場合などでMにならなくなるので途中の重さの情報を保存する必要があると気づく。→ そのためには0からM+1までの列を作ってdp[i][j]にはWiまでで重さjにできるかの真偽を格納すればよい


#  データ損失 ===================

# 3-5  部分和問題応用

解答遷移 WA AC

計 59:04

備考

配るdpでも貰うdpでもどちらでもよいが、min処理で更新していくため初期値はありえないくらい大きな値であるほうが都合がよい。初期値-1などにしてしまうと初期値か否かで余計な条件分岐が発生してしまう


# 3-6 部分和問題(応用２)

備考

dpするだけ

# 3-7 ボールと2つの箱

備考

➀　思考

bit全探索は無理。そのボールを左の箱に入れるかいれないかでdpできないか　→ すべての場合を表現すること自体は可能だが差の情報が得られないので差の情報に注目　→ そのボールを入れることでその分だけ差が増えるか減ることに注目してAC

なお、dpの列の大きさとしては、すべてのボールを片側に入れる時が差の最大値なためsum(W)分の大きさを設定すれば良い


#  189A Slot 

備考

なし

# ☆ 189B  Alcoholic   diff   274

ACできず諦め

備考

➀ 小数演算

215B(0726) , 224C Triangle(0820) などで小数16桁付近で情報が落ちると学んだが、実はそうではなくとも小数を扱う場合には正確な演算を行えない可能性が高い

例えば 0.07 + 0.07 + 0.07 は0.21000000000000002(0の数は適当)となってしまう。これは以下のように、そもそも小数は近似値で保存されてしまうことがほとんどであるからだ

![image](https://user-images.githubusercontent.com/109026838/189067746-85ff7968-08e2-436b-8332-039c31222b5c.png)

このような理由で小数演算の結果は誤差を孕む。したがって桁数によらず誤差を生じていることをかんがえなくてはいけない

➁　模範解答

➀の理由で小数演算を回避すべく、Xを100倍した値と、%の値をそのまま乗じたアルコール量を比較すれば整数の範囲での演算が行えるようになる



# ☆ 183D WaterHeater  diff 662

諦め

備考

➀ 逐次計算(シミレーション)

時刻で全探索。何人目であるかの情報を持ったSとTをソートしたSSi,TTiを作成し、そこから何人目かの情報を落して一次元化したSS,TTを時刻で二部探索。SSに挿入する位置leftが更新されればその分だけ使用量tmpを追加、TTに挿入する位置rightが更新されればその分だけtmpを減少させる。tmpがWを超えるか否かを判定することで目的の処理を行える

➁ imos method

時間ごとの使用量リストを作成し、使用開始時要素をP増加させ、終了時要素をP減少させ、累積和をとることで時間ごとの使用量を得ることができる。



③　itertools.accumulate(イテラブル)

イテラブルの累積和イテレータを生成できる



# 226C Marial artist   diff 539

解答遷移 AC

備考

dfs


# 207C Many Segments  diff 397

解答遷移 AC

備考

➀　思考

閉区間か開区間か考えなかった場合、左端点が小さい方の右端点right1ともう一方の左端点left2を比較して、right1>=left2であれば区間が重なる。そのうえでright1=left2だった場合に端点の情報で条件分岐すればよいとわかる。また2点a,bの組み合わせは全探索すればよいが、左端の大きさが大切なので、L,T,Rの順で情報を格納したリストを作成しsortすることで左端点の小さな方がどちらなのか決定させる。

➁　別解

開区間の場合端点を+0.5すれば条件分岐なしで皮革が行える。さらに全体を2倍すれば整数の範囲ですべての処理を行える

また、このとa,bの左端点のうち大きい方と、右端点のうち小さな方を比較すればよいのでmax,min処理を利用すればよい(ただしmax,min処理ではa,bどちらの端点であるかの情報が落ちるため、あらかじめ区間の変換を行っていない自分の案のような場合には扱えない)

③　余事象

模範解答では直接重複区間を求めるのが難しいため、区間が被らない条件を考えている。このように余事象を考えることは大切である　後述 178C



# 162B  Fizz Buzz Sum  diff 42

解答遷移 AC

備考

なし


================================================================================


# 0908

# 197A Rotate  diff 6

解答遷移 AC

計 01:03

備考

なし


# 197B Visibility  diff 96

解答遷移 AC

計 13:32

備考


# ☆ 179C A x B + C  diff 283

解答遷移 AC

発想　06：03　　AC  03:04  計 09:08

備考

➀ 解法

A * B + = N - C よりN以下の整数の約数を求める問題に見えるが、 約数列挙は工夫してもO(√N)なので全体でO(10^9)かかってしまう。したがってこの解法では解くことができない

次にAを全探索することを考える。C = N - A * B より 1<=N-A * B　これを変形して 1<=B<=(N-1)//A となるため、このAの場合の条件を満たすBの数は(N-1)//A　となる。この方法はO(10^6)なので間に合う。


# 177C Sum of product of pairs  diff 386

解答遷移 AC

発想 01:44   base 02:21  AC 01:28  計 05:34

備考

➀ 掛け算の和をまとめることで累積和を使えるようになるパターンのやつ


# ☆ 178C Ubiquity   diff　653 

解答遷移  方針がたたず諦め

備考

➀　思考

09と90に文字を挿入することを繰り返してカウントしようと考えたが、重複を排除する方法がわからない　→　setで処理しようにも挿入位置を全探索してその数字を求める必要がありそれは制約が許さず、setに10^9を超える要素を格納するのも難しい。　→　方針を変えてあり得る数字を全探索しようとしたが、10^(10^6)を探索できるわけもない　→　ここで策が尽きて諦め


➁　模範解答

余事象を考える。207Cでもあったが、何かを直接求めることが難しい場合に有力な方法になる。


③　pow(x,y,z)

x^yをzで割った余りを出力できる。(x^y)%Zとするよりも途中で随時あまりをとる処理のために高速で行えるらしい。pypyでも使用可能



# 0909

# 175B Making Triangle   diff 130

解答遷移 AC

問題把握&発想 00:49  AC 03:36  計 04:26

備考

なし

# 175C Walking Takahashi  diff 417

解答遷移 AC

base 作成 23:04   AC 01:05  計 24:09

備考

➀ 思考

探索はできないから計算で最小値を求めるのかな？　→  正なら負に、負なら正にとりあえず進むことが最適であること、Kの偶奇で止まれる場所が異なることを発見　→　行ったり来たりが可能なので、場合分けしなくてもKが奇数なら初期値をずらし、その後偶奇によらずKを半分に、Dを倍にすればすべての場合が同じ条件で扱えることを発見　→　さらにXは絶対値をとっても問題ないことも発見

あとはどうやって0に接近させるかだが、X//D が正側の最小値 X%D に接近するための最小回数であることに気づいたことでACできた。あとはX//DとKの大小関係に注意すれば完璧である。

スピードは速くはないが思考プロセスとしては十分なので満足



# 149C Replacing Integer diff 149

解答遷移 AC

発想 01:18  AC 01:35  計 02:53

備考

175Cの簡単ver




# 173D Chat in a Circle   diff 720

解答遷移 AC

発想 30:34  base 08:21  AC 01:50  計 40:47

備考

➀ 思考

座る順番はAの大きい順として、割り込み位置の前後要素[left,right]リストを作成して要素ごとの最小値の最大値が得られる心地良さであり、割り込み位置を示すことに気づくが、maxmin処理の後に挿入する値で更新するとなるとO(ΣN(N-1))でだいたいO(N^3)なので実装できない。

例) A[8 6 6 5 4]の場合 8 6 8をの挿入位置を[[8,6],[6,8]で表し、最大最小値は6なので[8,6]を[6,6]に変換して[8,6]をリストに追加する感じ。なおこの際6が含まれているものであればどれを変換しても結果に変化を与えないことを発見

この発見により現在の最大最小値の個数を管理すればよいのではないかと考える。新たな要素の追加で現在の最大最小値の個数を-1して0になるまではその心地よさが得られるという処理ができないか？　→ counterで管理して現在の最大最小値が0になればAを昇順でソートしたリストを二分探索し次の最大最小値に更新させる処理を考え無事ACできた



➁　模範解答

心地よさはA[0]+A[1]+A[1]+A[2]+A[2]+・・・を挿入回数のN-1回繰り返すことで最大値をとる。これは追加した値の左右の挿入位置を消費するまでその心地よさが得られ、次の最大値に移ることをくりかえす処理を最も簡潔に表している


# 166B Trick or Treat  diff 84

解答遷移 AC

計 05:12

備考

なし



# 0910 

# 262B Triangel(Easier)  2回目 diff 220

解答遷移 AC

計09:49

備考

0731のデータがなぜかないうえに記憶もまったくないのだが、当日の処理は今見ると意図が読めない。成長を感じる

# 262C Max Min Pair  2回目  diff 362

解答遷移 AC

計 11:00

備考

➀　思考

nC3で全探索はできない。Ai != i の場合はAi番目の要素にアクセスすればよいのでO(1)。Ai==iの場合にi番目以降のj番目がjであるかの処理を高速に行う方法を考える →　探索前にAi==iである全ての要素の数を数えてAi==i番目の探索時にその分だけansに追加する処理ならばO(N)で済むことに気づいてAC

➁ 0731時

Ai=iを満たす要素がX個だった場合、総数がXC2になることに注目して探索時に数え上げる処理を行っていた。nC2にわざわscipyを使っていたり、面倒なflag処理をしていたりと綺麗ではないが処理内容自体は〇


# 259B Counterclockwise Rotation　　2回目    diff 180  

解答遷移 AC

計 07:37

備考

複素数で計算するだけ。度数とラジアンの変換をでバックするまで勘違いしていて遅れた

0709時はわけのわからん条件分岐で解いている。煩雑すぎて読みかえす気も起きない




# 259C  XX to XXX  2回目  diff 451  

解答遷移 WA AC

計 21:28 +05:00

備考

➀ 思考

S,とTを前から探索すると、index番号がずれてしまうのでどの文字が何個続いているかのリスト作るか　→ WAを2つ出したので条件の見落としやコーナーケースを探す　→  Sのほうが文字の数が多いときもダメなことに気づいてAC

0709時も同じ思考でできている。













# Union Find 勉強





# ☆ 177D Friends  diff 732

諦め

備考

➀ N人それぞれの友達集合を作成し、その友達の友達集合との差集合を追加していく処理を考えたが、nC2程度かかる場合もあるので間に合わない　→　ほかに打ち手もなく降参

➁ Union Find


 





# 2分探索 勉強➁ 二分法

# アルゴ式 2分法

# Q2-1 方程式を解く

備考

➀ 二分法

リスト内の挿入位置を調べるにはnp.searchsortedなどの二分探索が役立つが、対象がリストでない場合には使えない。

したがってこの問題では、方程式の近似解を求めるためのアルゴリズム二分法を使って解を求める




