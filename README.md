# 0829 

# Unlucky 7  diff 131

解答遷移  AC

問題把握 00:13  発想 00:00   base 04:30  デバック&提出 02:05

備考

➀ 8進数

整数Nの8進数文字列は f"{N:o}"で出力可能




# 185C Duodecim Ferra diff 374　

解答遷移 WA 諦め(再解答の必要はなし)

問題把握 01:42  発想 + base 08:18  計 21:14 諦め


備考

➀ scipy.special 整数型

![image](https://user-images.githubusercontent.com/109026838/187097939-c96a938b-fa12-4ad8-8ab6-90d48c2a0c79.png)

int(comb((L-1),11))としたためにL=200などの大きな値の処理が正確出来なかった。

3つだけWAが発生してコーナーケースを考えたが存在しないと結論付けた。そこで上限値でなにか問題が発生しているのかなと考えたはしたのだが、その場合はどうせ解けないなとcombの仕様を調べようともせずににすぐ諦めてしまった。仕様を知らなかったことは仕方ないが、この努力をできなかったことを大きく反省する。


# ABC171D Replacing    diff 498

解答遷移 AC

問題把握 01:13  発想 01:31  base 04:48  デバック&提出 05:12  計 12:46

備考

なし



# 258C Rotation  2回目   diff 419    類題 199C

解答遷移 AC

問題把握 01:22  発想 11:08  base 03:16  デバック&提出 01:04　計 16:52


備考

➀ 思考

クエリ1で本当に入替を行うのは無理だから疑似いれかえをしたいな →  最初のindex番号をキーに、要素をvalueにした辞書を作ることを考えたが、キーを変化させるにはループが必要になるからこれじゃだめだな。→ 結構時間をかけて考えた後、クエリ２で取り出す場所の方をいれかえを反映させた数字にすればよいこと気付いてACできた





# 187C 1-SAT   diff 207

解答遷移 AC

問題把握 02:01  発想 09:15  base 06:02  デバック&提出 12:24  計 29:43


備考

➀ 速度ボトルネック

題意読み取りミスが原因。Sを揃えてから存在確認の判定を必要があることになかなか気づかなかった。

また解法もナンセンス

そもそも調べる文字列が"!"つきか否か分類する必要がない。例えば red は red , !red を調べるのに対して、!red なら !red , !!red であるため、なにか特別な処理を施さなくても自然に異っていて条件で区別する必要がないことを読み取れななかった。



* この読み取りミスの原因は部分的な処理に頭を使ってしまうこと？

今回では!をうまく処理するためにpopがいけるかどうかみたいなことに9割思考を割いてしまうせいで、やらなければいけないことが曖昧なまま方針を進めたり、コードを書いてしまうことが原因かもしれない。速度ガ大切なため完全に整理してから進めるのは不可能だが、全体を俯瞰する姿勢をとる必要がありそう。



# 265C  Comma   diff 265

解答遷移 AC

問題把握 00:40  発想 05:44  base 05:44  デバック&提出 02:57  計 15:07  

備考

➀ 速度ボトルネック

N < 10^s における探索時の個数処理の正確さが不安で確認を慎重に行ったために作成時に時間がかかってしまった。N+1<=10^sなのだからどんなNであってもmin処理の結果が同じことが時間をかけないとわからなかった。


➁　別解(模範解答)

その数に何個のカンマがあるのかに注目する自分の解答とは異なり、その数に特定の位置のカンマが存在するかに注目することもできる。例えばN=7,777,777の場合、3-4桁目,6-7桁目のカンマは存在するが、9-10桁目,12-15桁目,18-19桁目のカンマは存在しない。よって+2のように考えることも可能。





# 0831 

# 176C Step  diff  72

解答遷移 AC

問題把握 00:21  base 04:21  デバック&提出 01:35  計 06:18

備考

なし


# 209C  Not Equal  diff 285 

解答遷移 AC

発想まで?  11:44   baseから提出まで? 05:23   計 17:07  (境界が曖昧)

備考

➀ 思考

素直に実装すると、Cの要素を前から探索して、その要素の値以下の数値を探索していくことになるがそれは無理だな。　→ 逆にどんな数値かを探索して、setで重複処理すればいけるか？ でも、Aが数値ではないので探索ができない  

Cの制約的に探索するのかと思ったが、思いつく限りの探索方法を講じても制約を突破できないので何か直接答え出力する方法がないか探してみる。 → sortして前から順に、i番目に(要素-i)の値をかけていく処理をすればよいことに気づいてAC


とても速い提出とはいえないが、プロセス自体は良いと思うので、あとは自分自身の思考処理がはやくなれば完璧





# 189C Mandarin Orange  diff 565

解答遷移  AC

問題把握 02:38  発想 18:44  base 03:30  デバック&提出 00:52  計 25:46

備考

➀思考

前から探索しても、区間を探索できないから組み合わえ使うか？ でも5.0 * 10^7で無理ではないが他のより高速な処理を探そう　→ 探索開始位置と終了位置を二重ループで操作するのはどうか？　これも結局同じか　

setならmin処理が速いか調べたりしながら、ここでようやく区間の始点終点を決めても取り出すのにO(l)かかるからこれじゃだめなことに気づく。

発想を変えてAの要素で探索しようとしたところ 5.0 * 10^7にはなるがこれで解答は一応できることがわかったので、ほかに案もないしダメもとで出したらACできた。


➁模範解答

よく考えたら区間をとりだす必要はなく、その区間での最小値さえわかればよいので自分が捨てた方針でACできる。ただしmin処理に注意

➁ pypy 

➀でも記述したが、5.0 * 10^7 ならpypyで通る






#  0901  

# 176B Multiple of 9     diff  51

解答遷移 AC

問題把握 00:45  base 01:06  デバック&提出 00:41  計 02:33

備考

なし


# 177B Substring     diff  193

解答遷移 AC

備考　

なし



# 166C Peak   diff 263

解答遷移 AC

計 24:21

備考

➀　思考と計算量

各展望台について隣接する展望台のリストを作ってその最大値をmaxで取得する場合、O(N^2)になるためこれではだめだなと思って、熟考し最大値のみを保有することでO(N)の解答を導くことができた。

しかし、却下した方針でも普通にACできた。これは、ある展望台については他全ての展望台と隣接することはあっても、隣接候補が2M個しかないために探索回数はO(N^2)ではなくO(2M)になるからだと思われる。




#  Alter Altar     diff  486

解答遷移 AC

問題把握  04:07  発想 24:27   提出まで 02:32  計  31:56


備考

➀ 思考

1,アルゴリズム理解 09:49  + 2,コードでどう実装するかの思考 15:27  の計24:27を発想段階で費やした。(少しコードも書いてはいるがほぼ思考時間)


とりあえずシミレーション。入替と色変えの効率を比べたりしながら、石の入れ替え位置候補が多すぎてこれを探索することは不可能だと感じ、操作完了時の石の状態に注目してみた。すると最も右の位置にある赤石と最も左の位置にある白石が...w...R...のように白 < 赤になっている場合にはまだ操作が必要で、そうでないなら操作完了になるなと気が付く　 1  → 白石と赤石の位置を調べあげ、初めて白 > 赤　になるindex回操作が必要である処理でAC 2




# 196B  Round Down   diff 39

解答遷移 AC

問題把握 00:13    提出まで 03:31   計 03:45   

備考

➀ 思考

floatで受け取って、math.floorすればいいや。→ sample3で、入力を受け取った時点で小数16桁付近から情報が落ちていることを確認。仕方なく文字列として受け取り前から "." まで探索し出力する方針でAC

割算演算の結果のみでなく、入力時点でも情報が落ちてしまうことに気を付ける




# 0902

# uNrEaDaBlE sTrInG   diff  23

解答遷移 AC

計 04:18

備考

➀ 小文字 / 大文字判定

文字列.islower() /  .isupper()にて文字列が全て小文字か大文字かを判定できる



# Unexpressed   diff 379

解答遷移 WA  WA  AC

問題把握 00:49   発想  02:49   base  03:40   初提出までのデバック  12:36   AC 08:17   計 28:12 +10:00


備考

➀　注意点

1, 重複処理

たとえば 16　のような 2^4　とも 4^2 とも表現できる数字のカウントを正確に行わなくてはいけない

2, break処理

a^2 > N となった場合、(a+1) ^2 >Nなので処理をうち切りたい。b=2のまま処理が終了したことを表すflagを使ってprintする処理を実装した場合、ループ回数が十分に大きくないと10^10の場合にprintされないことになる。詳しくはコード参照




# ☆ 226D Teleportation     diff 706

平行な場合にも同じ魔法であることを処理できず諦め

問題把握 04:14  発想 29:13  base 11:55  　計 1:04:32


備考

➀ 傾きと最大公約数

2点間の変化量を表す傾き dy/dxを素直に実装すると割算になって不便であることは　226C(0820) でも学んだが、dxとdyの最大公約数gによって(dx/g,dy/g)により、その傾きを代表するベクトルを表現できる。

なお、a,bの最大公約数はmath.gcd(a,b)にて O(log(max(a,b))で出力可能


➁ hash化　タプルとリスト

辞書のキーやsetの要素にリストは渡せないが、タプルなら可能


③ 解答補足

combinationsを使っ探索し結果を2倍する処理では正解できない。なぜなら傾きの絶対値が同じ2点であってもベクトルが違えば傾きが変化しsetにどちらも格納されることになってしまうからである



#  148C  Snack

解答遷移 AC

計 05:35

備考

➀　最小公倍数

a,bの最小公倍数は　a * b // gcd(a,b)  で求められる





# 224C Triangle? 2回目

解答遷移  RE ➁ / TLE ③ / AC ➀

計 27:15 + 10:00

備考

➀　最大公約数解法

226Dで傾きを最大公約数で解釈できるようになったので練習がてらこの問題を最大公約数を利用して解いてみた。この問題では選んだ3点において、同一直線状にあっても始点の決め方でベクトルの向きが変ってしまうこと、にさえ気を付ければこの解法でもACすることができた。

ただし模範解答の、傾き分母払い解法であれば逆ベクトルを考える必要がないためこちらの方が楽である。


➁scipy と pypy

pypypではnumpy 同様にscipyも扱えない。そのためこの問題をpypyで通したいなら、N* (N-1)* (N-2)//6とするしかない

③ 計算量

NC3 * log(max(dx,dy)) はx,y <= 10^9　により 10^8近くなる。そのためpythonで最大公約数解法は使えない



# 0903

# 048A A to Z String   diff 54

解答遷移  AC

計 01:59

備考

なし


# 053B A to Z String  diff 164

解答遷移  AC

計 07:33

備考

➀　解法

読み違えたままACしてしまったが、この問題ではZが来ても数をリセットするのではなく、最左のAの位置と最右のZの位置が分かればよい問題である




# 連結リスト Linked List 勉強

ノードのつながりを記憶するデータ構造。インスタンスにその前後のインスタンスを記憶させて、挿入をくりかえすことで一つの連結リストを作成する

・ LikedList インスタンス式

https://www.delftstack.com/ja/howto/python/linked-list-in-python/

ノードの挿入などの関数を持つ全体のクラスを作成し、これを操作してノードインスタンスを連結させる方法

・アルゴ式

https://algo-method.com/tasks/844/editorial

最初と最後のノードnilを作り、nilを目印にして連結する方法


・欠点

abc225(後述) に顕著であるが、特定の位置にアクセスすることができない。前から辿って見つける必要がある。

https://www.momoyama-usagi.com/entry/info-algo-list#i-2





# ☆ abc225D  Play Train   diff  778

方針がたたず諦め

備考

➀ 双方向連結リスト

上述した連結リストの考えで解答可能。ただし生成される連結リストが一つではない点、アクセスが不便な点からTrainクラスの連結でこの問題を解くことは難しい。

そこでリストのtrain番号に対応した場所にその電車の前にある電車と後ろにある電車の情報を格納したリストを格納することで操作1,2をO(1)で処理することができる。もしくは前の電車の情報と後ろの電車の情報をそれぞれ別のリストにわけて記憶することでも解答可能




# ☆ 181D Hachi    diff  600

解法がわからず諦め

備考

➀　思考

並び替えの探索は不可能なのでそれ以外の方針をとるべきだとは思ったものの、8進数や他の方針を考え始めて、しまいには8の倍数の判定方法を調べることもせずあきらめてしまった。

８の倍数を列挙して4の倍数の様に下2桁に注目して8の倍数以外もあるなと最初に気づき、そこでこの方針はだめだと打ち切ったことを引き釣り判定方法わからないと結論付けて調べようともしないこの姿勢がダメ


➁ 8の倍数

1000 = 125 * 8 であることに注目すると、例えば 5424 → 5* 1000^1  + 424 * 1000^0 より 424 が8の倍数であることと、5424が8の倍数であることの真偽は一致する




#  180A  box  

解答遷移 AC

備考

なし


#  180B Various distances   diff 129

解答遷移 AC

備考

なし



# ☆　211C  chokudai  diff 559

解答遷移 TLE 諦め

備考

➀ 思考

chokudaiを構成する8文字のそえぞれがSに出てくる場所さえわかれば、cから順に次の文字を二分探索すれば、例えば8文字すべてに10^5 /8 個登場するとしても 10^5 / 8 * 10g(10^5 / 8)^8 で間に合うと思った。

しかし実際に実装してみると次の文字の中でもある文字を動かす必要があり結局これではループが8重になりTLEすることに気づいた。

かなり時間を使ってようやくdpっぽく処理できるなと気づき導入。chokudaiリストと同じ形状のdpを作って、dp[n][m]を文字nの中のm番目のものを使ってchokudaiのnの文字までの組み方の数を表して、nのm番目とn+1のm`番目を比較してm<m`ならばdp[i+1][m`]+=dp[i][m]とすればよいと考えた。　→ しかしこれでは8つの文字それぞれにおいて前から順に探索が必要な点が解消されていないのでACできずTLEしてしまった


➁　模範解答

dp

Sに出てくるn番目の文字でchokudaiのある場所までを表現することができる総数に注目する。例えばn番目がkならn-1番目までで作ったoまでの文字列が新たにkまで構成できるようになるのでdp[n][kを表すindexl+=dp[n-1][kを表すindex]+dp[n-1][oを表すindex]  * が成り立つ

またcにおいては前の文字がなく、dp[n][cを表すindex]=dp[n-1][cを表すindex]+1となるが、すべての要素が1の-1列目をdpに追加すれば他の処理と同じく * 式で済む

また、実はdpでは直前の情報以外使用しないので、すべての情報を記憶する意味はない。よって9列の一次元リストを作成し、S[i]がchokudaiを構成するならばdp[S[i]の表すindex+1] = dp[S[i]を表すindex]として古い情報を更新してしまうことも可能




# 0905

# Changing Jewels   diff  413　　2回目

解答遷移  AC

計 09:47

備考

➀ dpで解答



# アルゴ式 dp基礎編

# 3-2 部分和問題

解答遷移 AC

計 25:00

備考

➀ 思考

2^100は探索できない。M以下の最大値を保存していてもW1+WN=Mだった場合などでMにならなくなるので途中の重さの情報を保存する必要があると気づく。→ そのためには0からM+1までの列を作ってdp[i][j]にはWiまでで重さjにできるかの真偽を格納すればよい


#  データ損失 ===================

# 3-5  部分和問題応用

解答遷移 WA AC

計 59:04

備考

配るdpでも貰うdpでもどちらでもよいが、min処理で更新していくため初期値はありえないくらい大きな値であるほうが都合がよい。初期値-1などにしてしまうと初期値か否かで余計な条件分岐が発生してしまう


# 3-6 部分和問題(応用２)

備考

dpするだけ

# 3-7 ボールと2つの箱

備考

➀　思考

bit全探索は無理。そのボールを左の箱に入れるかいれないかでdpできないか　→ すべての場合を表現すること自体は可能だが差の情報が得られないので差の情報に注目　→ そのボールを入れることでその分だけ差が増えるか減ることに注目してAC

なお、dpの列の大きさとしては、すべてのボールを片側に入れる時が差の最大値なためsum(W)分の大きさを設定すれば良い


#  189A Slot 

備考

なし

# ☆ 189B  Alcoholic   diff   274

ACできず諦め

備考

➀ 小数演算

215B(0726) , 224C Triangle(0820) などで小数16桁付近で情報が落ちると学んだが、実はそうではなくとも小数を扱う場合には正確な演算を行えない可能性が高い

例えば 0.07 + 0.07 + 0.07 は0.21000000000000002(0の数は適当)となってしまう。これは以下のように、そもそも小数は近似値で保存されてしまうことがほとんどであるからだ

![image](https://user-images.githubusercontent.com/109026838/189067746-85ff7968-08e2-436b-8332-039c31222b5c.png)

このような理由で小数演算の結果は誤差を孕む。したがって桁数によらず誤差を生じていることをかんがえなくてはいけない

➁　模範解答

➀の理由で小数演算を回避すべく、Xを100倍した値と、%の値をそのまま乗じたアルコール量を比較すれば整数の範囲での演算が行えるようになる



# ☆ 183D WaterHeater  diff 662

諦め

備考

➀ 逐次計算(シミレーション)

時刻で全探索。何人目であるかの情報を持ったSとTをソートしたSSi,TTiを作成し、そこから何人目かの情報を落して一次元化したSS,TTを時刻で二部探索。SSに挿入する位置leftが更新されればその分だけ使用量tmpを追加、TTに挿入する位置rightが更新されればその分だけtmpを減少させる。tmpがWを超えるか否かを判定することで目的の処理を行える

➁ imos method

時間ごとの使用量リストを作成し、使用開始時要素をP増加させ、終了時要素をP減少させ、累積和をとることで時間ごとの使用量を得ることができる。



③　itertools.accumulate(イテラブル)

イテラブルの累積和イテレータを生成できる



# 226C Marial artist   diff 539

解答遷移 AC

備考

dfs


# 207C Many Segments  diff 397

解答遷移 AC

備考

➀　思考

閉区間か開区間か考えなかった場合、左端点が小さい方の右端点right1ともう一方の左端点left2を比較して、right1>=left2であれば区間が重なる。そのうえでright1=left2だった場合に端点の情報で条件分岐すればよいとわかる。また2点a,bの組み合わせは全探索すればよいが、左端の大きさが大切なので、L,T,Rの順で情報を格納したリストを作成しsortすることで左端点の小さな方がどちらなのか決定させる。

➁　別解

開区間の場合端点を+0.5すれば条件分岐なしで皮革が行える。さらに全体を2倍すれば整数の範囲ですべての処理を行える

また、このとa,bの左端点のうち大きい方と、右端点のうち小さな方を比較すればよいのでmax,min処理を利用すればよい(ただしmax,min処理ではa,bどちらの端点であるかの情報が落ちるため、あらかじめ区間の変換を行っていない自分の案のような場合には扱えない)

③　余事象

模範解答では直接重複区間を求めるのが難しいため、区間が被らない条件を考えている。このように余事象を考えることは大切である　後述 178C



# 162B  Fizz Buzz Sum  diff 42

解答遷移 AC

備考

なし


================================================================================


# 0908

# 197A Rotate  diff 6

解答遷移 AC

計 01:03

備考

なし


# 197B Visibility  diff 96

解答遷移 AC

計 13:32

備考


# ☆ 179C A x B + C  diff 283

解答遷移 AC

発想　06：03　　AC  03:04  計 09:08

備考

➀ 解法

A * B + = N - C よりN以下の整数の約数を求める問題に見えるが、 約数列挙は工夫してもO(√N)なので全体でO(10^9)かかってしまう。したがってこの解法では解くことができない

次にAを全探索することを考える。C = N - A * B より 1<=N-A * B　これを変形して 1<=B<=(N-1)//A となるため、このAの場合の条件を満たすBの数は(N-1)//A　となる。この方法はO(10^6)なので間に合う。


# 177C Sum of product of pairs  diff 386

解答遷移 AC

発想 01:44   base 02:21  AC 01:28  計 05:34

備考

➀ 掛け算の和をまとめることで累積和を使えるようになるパターンのやつ


# ☆ 178C Ubiquity   diff　653 

解答遷移  方針がたたず諦め

備考

➀　思考

09と90に文字を挿入することを繰り返してカウントしようと考えたが、重複を排除する方法がわからない　→　setで処理しようにも挿入位置を全探索してその数字を求める必要がありそれは制約が許さず、setに10^9を超える要素を格納するのも難しい。　→　方針を変えてあり得る数字を全探索しようとしたが、10^(10^6)を探索できるわけもない　→　ここで策が尽きて諦め


➁　模範解答

余事象を考える。207Cでもあったが、何かを直接求めることが難しい場合に有力な方法になる。


③　pow(x,y,z)

x^yをzで割った余りを出力できる。(x^y)%Zとするよりも途中で随時あまりをとる処理のために高速で行えるらしい。pypyでも使用可能



# 0909

# 175B Making Triangle   diff 130

解答遷移 AC

問題把握&発想 00:49  AC 03:36  計 04:26

備考

なし

# 175C Walking Takahashi  diff 417

解答遷移 AC

base 作成 23:04   AC 01:05  計 24:09

備考

➀ 思考

探索はできないから計算で最小値を求めるのかな？　→  正なら負に、負なら正にとりあえず進むことが最適であること、Kの偶奇で止まれる場所が異なることを発見　→　行ったり来たりが可能なので、場合分けしなくてもKが奇数なら初期値をずらし、その後偶奇によらずKを半分に、Dを倍にすればすべての場合が同じ条件で扱えることを発見　→　さらにXは絶対値をとっても問題ないことも発見

あとはどうやって0に接近させるかだが、X//D が正側の最小値 X%D に接近するための最小回数であることに気づいたことでACできた。あとはX//DとKの大小関係に注意すれば完璧である。

スピードは速くはないが思考プロセスとしては十分なので満足



# 149C Replacing Integer diff 149

解答遷移 AC

発想 01:18  AC 01:35  計 02:53

備考

175Cの簡単ver




# 173D Chat in a Circle   diff 720

解答遷移 AC

発想 30:34  base 08:21  AC 01:50  計 40:47

備考

➀ 思考

座る順番はAの大きい順として、割り込み位置の前後要素[left,right]リストを作成して要素ごとの最小値の最大値が得られる心地良さであり、割り込み位置を示すことに気づくが、maxmin処理の後に挿入する値で更新するとなるとO(ΣN(N-1))でだいたいO(N^3)なので実装できない。

例) A[8 6 6 5 4]の場合 8 6 8をの挿入位置を[[8,6],[6,8]で表し、最大最小値は6なので[8,6]を[6,6]に変換して[8,6]をリストに追加する感じ。なおこの際6が含まれているものであればどれを変換しても結果に変化を与えないことを発見

この発見により現在の最大最小値の個数を管理すればよいのではないかと考える。新たな要素の追加で現在の最大最小値の個数を-1して0になるまではその心地よさが得られるという処理ができないか？　→ counterで管理して現在の最大最小値が0になればAを昇順でソートしたリストを二分探索し次の最大最小値に更新させる処理を考え無事ACできた



➁　模範解答

心地よさはA[0]+A[1]+A[1]+A[2]+A[2]+・・・を挿入回数のN-1回繰り返すことで最大値をとる。これは追加した値の左右の挿入位置を消費するまでその心地よさが得られ、次の最大値に移ることをくりかえす処理を最も簡潔に表している


# 166B Trick or Treat  diff 84

解答遷移 AC

計 05:12

備考

なし



# 0910 

# 262B Triangel(Easier)  2回目 diff 220

解答遷移 AC

計09:49

備考

0731のデータがなぜかないうえに記憶もまったくないのだが、当日の処理は今見ると意図が読めない。成長を感じる

# 262C Max Min Pair  2回目  diff 362

解答遷移 AC

計 11:00

備考

➀　思考

nC3で全探索はできない。Ai != i の場合はAi番目の要素にアクセスすればよいのでO(1)。Ai==iの場合にi番目以降のj番目がjであるかの処理を高速に行う方法を考える →　探索前にAi==iである全ての要素の数を数えてAi==i番目の探索時にその分だけansに追加する処理ならばO(N)で済むことに気づいてAC

➁ 0731時

Ai=iを満たす要素がX個だった場合、総数がXC2になることに注目して探索時に数え上げる処理を行っていた。nC2にわざわscipyを使っていたり、面倒なflag処理をしていたりと綺麗ではないが処理内容自体は〇


# 259B Counterclockwise Rotation　　2回目    diff 180  

解答遷移 AC

計 07:37

備考

複素数で計算するだけ。度数とラジアンの変換をでバックするまで勘違いしていて遅れた

0709時はわけのわからん条件分岐で解いている。煩雑すぎて読みかえす気も起きない




# 259C  XX to XXX  2回目  diff 451  

解答遷移 WA AC

計 21:28 +05:00

備考

➀ 思考

S,とTを前から探索すると、index番号がずれてしまうのでどの文字が何個続いているかのリスト作るか　→ WAを2つ出したので条件の見落としやコーナーケースを探す　→  Sのほうが文字の数が多いときもダメなことに気づいてAC

0709時も同じ思考でできている。



# 0910

# abc 268 記録

# 268A Five Integers

解答遷移 AC

計 01:18 

備考

なし

# 268B Prefix?

解答遷移 AC

計 02:30

備考

なし

# 268C Chinese Restaurant    diff 676

解答遷移 AC

計 40:34

備考

➀　思考

料理のならびを全探索するTLE確実な方針しか思いつかず、実験してみることに　→　たとえば 3,6と料理が並んでいた時 3が4の位置にいる時6は5の位置にいて両方条件を満たすことが判明　→ つまりi番目の料理は1場目の料理が　pi-1-i,pi-i,pi+1-i のいづれかに存在する場合に条件を満たすことを理解。　したがって料理を前から全探索し、条件を満たす1番目の料理の位置を+1する処理をし最も条件を満たした位置を出力する処理で完了できるはず　→ AC


方針がたたずdpを試したり、それでもうまくいかなかったりして緑diffなのかなと諦めかけたが、順位表を見てもDが先に解かれている様子もなかったためいろんな視点で実験してみたところうまくいった。最終的なパフォーマンスから見ても十分健闘できた


# 268D  Unique Username  diff 1309

解答遷移 無数のWA

終了時まで思考しACできず

備考

➀ 思考と解答例

permurationで順番を探索し、各位置に _ を何個挿入するかをproductで探索する方針をとった。方針自体は全く問題なかったがこの方針でbaseを完成させたのが終了まじかだったこともあって十分デバックして確認することができなかった。


挿入する位置の数で挿入できる _ の最大値が変化することなど productで作るpoints タプルの要素および要素数を精査することで同じ方針でACすることができる。しかしpointsの要素をN-1,Nのどちらで作ろうが,また要素の最大値をありえる範囲で作ろうが作らまいが、生成する文字列の長さで最終的にありえないものを排除できるはずなのだが 入力 01-one_04でのみ結果が異なるようである。

一日使ってあらゆる実験をためしてみてもなぜ結果が異なるのかつきとめることができなかった。サンプルが公開され次第確認すること(ssssに実験の記録を残す。内容はランダムに作成したサンプルに対してAC処理とWA処理の出力をテキストに出力するもの。ソフトに投げれば差がわかるはずだった。。。)



➁ 入力データ生成

https://timesaving.hatenablog.com/entry/2022/04/29/150000

上サイトやssssのようにして文字列を作成できる。これを使えばなぜWAなのかわかるケースが将来あるはず

③ a^b

a や b が 1異なるだけで一桁変わるほどなのでproductの引数は十分精査する必要がある。この問題でも _ の挿入位置数、挿入可能最大値を正確に与えればACできる処理でもこれを怠るとTLEしてしまった



# 154C Distinct or Not  diff 64

解答遷移 WA AC

発想 00:56  base 00:48  AC 03:24  計 04:59 + 05:00

備考

➀ 出力文字が大文字であることに気づかずWAを出す。方針を再考察し間違っていると思えなかったので問題をもう一度読み返したところ出力がいつもと違う文字を要求していることに気づいてAC


# 139C Lower    diff  152

解答遷移 AC

計 08:25

備考

➀　思考

前から順に探索し、つぎの高さより低い位置になるまでcountしていき、その条件を満たす位置で現在の最大カウントと比較することその位置までの区間における最大値を求められる。カウントをリセットして探索を続ければ全区間の最大値を求められる。更新途中でループが修了した場合のためにループを抜けたあとで追加の比較を行うことでAC




# 0912  

# 151A Next Alphabet  diff 13

解答遷移 AC

計 01:40

備考

なし


# 151B Achieve the Goal  diff 40

解答遷移 AC

計 03:10

備考

サンプルが親切でなければ、既にN * K を超えている場合に負数を出力していた。注意


# 151C  Welcome to AtCoder diff 333

解答遷移 WA AC

計 12:36 + 05:00

備考

ACをとっているかのリストを用意してFalseの間処理すればよいと考えて提出したがWA → ACしていない問題はいくらWAをカウントしていようが集計しないことを見落としていたのでWAの数もリストで管理して、ACしている問題だけそこからWAの数を取り出す処理を加えてACできた


# 240C Jumping Takahashi  diff 464

解答遷移 AC

計 08:38

備考

なし


# 240A Edge Checker 2回目  diff 7

解答遷移 AC

計 03:07

備考

循環型の性質をいかして余りで処理すれば 1 →  2　などと 10 → 1 を同列に扱うことはできるが逆方向の 1 → 10は同列に扱えない。進行方向が異なるからである(2 → 1などとは差が1などで同列に扱える)。したがってふつうに10の場合のみ特別に処理するべきである



# 227C ABC conjecture    diff 692

解答遷移 AC

計 32:26

読み取りミス 有


備考

➀ 思考

約数列挙で間に合うわけがなく 、10分ぐらい探索対象を考えたがわからないままだったので実験開始。ここでようやくN以下の数なことに気が付く。また勘違いしていたがa,bが定まっているならば、N以下だろうがちょうどNだろうがO(1)で求められることに気づく。したがってa,bの探索が間に合うのかについて考察すると、aの最小値1のときbの探索のために √N 回必要で、かつaの探索は合計で 3√N 回必要だから10^8を超えることはないと思って試しに10^11でテストしてみたところ通ったので提出してAC

読み取りミス + 計算量勘違い + 計算量見積もりの遅さ　で必要以上に時間がかかってしまった




➁　計算量

https://atcoder.jp/contests/abc227/editorial/2906

実際に積分してみるとたしかにN^(2/3)の項が最大の項だった。



# 255B Lights It Up   2回目    diff　351

解答遷移　AC

発想 02:45  base 11:53  AC 03:37 　計 18:17

備考

➀ 思考

あるライトを持っている人とライトをそもそももっていない全ての人の距離の最大値が、そのライトで全ての人を照らすための最小値だから、これを全てのライトで求めてどのライトで照らすのがもっとも効率的かminで求めればいいと思った　→ サンプル3で間違いに気づく。

ライトを持っていないある人を照らすための最小値を求める。すべての人を照らすにはもっとも照らすのに距離が必要な人を照らすことができればよいのでこれらの最大値を求めればよい。

➁ numpy演算

最大最小演算をnumpyで行えばループなしの高速な実装が実現するのでは？　→ (K,N,2)の1次元方向にすべての人の位置を格納した配列をK個3次元方向に格納した配列1 と 1次元方向にN個の同じライトの位置を格納した配列を3次元方向にすべてのライトK個格納した配列2を作る。　→ (1-2)^2 の和を2次元方向にとることでライトと人の距離の(K,N)配列ができる。求めたいのはある人を照らすための最小値の最大値だから、1次元方向の最小値をとればすべて人の最小値が格納された(K,)配列が生成され、これの最大値が解となる。

確かに処理の中にループは含まれてはいないのだが、(K,N,2)の配列を生成する際に時間がかかってとても遅い処理になっている

![image](https://user-images.githubusercontent.com/109026838/189896500-e25cc944-bfe9-46e3-ba11-6d76dc1e7e01.png)

test_21 サンプルでのコードテスト。出力1が配列正整部。出力2が最小最大値計算処理部。

これであればライトごとの計算はループで行う実装(昔作成したコード)のほうが何倍も速い。


* また、numpyは内部でC++が組み込まれている関係でpythonのように無限に整数を扱えない。例えば1000^2+1000^2はオーバーフローしてしまう。dtypeをint型にすれば回避できるが速度が遅くなる？らしい。numpyを使うときは注意



# 0913

# 254B Practical Computing   2回目 diff 45

解答遷移 AC

発想 01:23  base 02:10  AC 01:27  計 05:00

備考

なし


# 251B At Most3(Jude ver)  2回目   diff  181

解答遷移 AC

発想 01:01  AC 10:05  計 11:06

読み取りミス　有

備考

➀ 注意点

同じ数字でカウントするのは一回だけ

またあらかじめ0の重りを2つ追加で用意すれば、任意の3個を選ぶ処理だけで、疑似的に3つ以下の重りを選ぶ操作を実現できる


# 182C To 3  2回目  diff 292 

計 18:35

備考

➀　思考

N%3 に注目。0なら消す必要なし。1ならNを構成するいづれかの数字のうち余りが1のものを削除するか2のものを2つ削除すればよいことに気づく。(2の場合は2を1か1を２つ消せばよい)  → collectionsを用いて削除する数が最大で桁数-1個であることに気を付けてAC


➁ bit

計算量に気を付けているなら➀の解答が先に思いつくが、18の数字を消すか消さないかの問題なのでbit全探索も可能




# 247B Unique NIcknames   2回目  diff 202

解答遷移 WA AC

問題把握 01:55   発想 01:04  AC 08:59   計 11:59 + 05:00

備考

自分自身の姓名は被ってもいい点に注意




# 245B Mex  2回目  diff  40

解答遷移 AC

計 15:32

備考

➀　思考

ソートしリストを前から探索し、次の数字が一つ大きければそのまま進み、そうでなければ出力する処理を思いついた。　→  連続数や同じ数字が続く場合にうまく処理できないので条件分岐を考える。　→　うまくいきそうにないので見た数字を記憶して出現していない最小値を出力することでAC

➁ 別解

1, 差集合

2, setで重複をなくしsort。前から探索し、インデックス番号と異なればインデックス番号を出力する



# 242B Minimize Ordering    2回目   diff  45

解答遷移 AC

計 04:07  

備考

文字列もソートできる


# 246B Get Closer   2回目   diff  79

解答遷移 AC

計 03:06

備考

実部虚部の出力はZ.real,Z.imagで可能



# 243B Hit and Blow  2回目  diff 26

解答遷移 AC

備考

➀　解法

1, 積集合で共通要素を調べ、Aを前から探索。同じインデックス番号でA=Bなものを数え、それを共通要素から引けば位置の異なる数もわかる

2,共通要素があるときAの要素でその共通要素がBのどこに存在するのかアクセスできたらうれしい。→ Bの要素をkeyにindexを要素にした辞書を作ればいい


# 243 Shampoo  2回目   diff 18

解答遷移 AC

発想　01:48   AC 02:37   計 04:25

備考



# 0914

# 260B Better Students Are Needed!  2回目   diff 195

解答遷移 AC

計 17:54

備考

➀ 思考

not in で処理したいが、回数で制御できないくなるからwhileするか。でもこれって間に合うのか？　→ 英語の合格者を選出するためのループ回数が最高でX+Yなことに気づたことで、ループ合計回数が 6 * 10^3　であること、またX+Y回ループして合格者が合計X+Y人になればbreakする処理ｍならforで制御できることに気づいてAC



# 250B Enlarged Checker Board   diff 109

解答遷移 AC

計  10分未満(計測ミスで消してしまったが8～9分くらいだったのを見た)

備考

なし


# 252C Slot Strategy    2回目  diff 441

解答遷移 AC

計 26:59

備考

➀ 解法

どの数字で止めるか全探索。Counterでどの列にあるか管理し、最頻値を求める。


# 232B  Caesar Cipher  2回目   diff 82

解答遷移 WA  AC

計測ミス

備考

➀ a→b とz→a を同列に扱うために余りを利用する



# 241C connect6    2回目   diff  664 

解答遷移 AC

計 17:27

備考

➀　思考

マスを全探索。特定の方向に向かって6マス進み黒マスをカウントして4以上かどうか判断する処理でいいな。6マス済めない場合を条件処理してAC


➁　別解

進行方向ごとに、黒マスの数を累積させた新しいデータを作成し6マス先のマスが3か4増加しているかどうか判定する(始点のマスの色で区別)。この処理はマスを進む際にループを発生させないため、どんな連続マスであってもO(4* N^2)で処理できる




# 233C Product   2回目  diff 604

解答遷移 AC

計22:23

備考

➀　思考

制約がよくわからないけど、方針をたててからそれがいけるのか判断するときに制約の考察をしよう。　→  無難に再帰関数で袋ごとにループしたい。ここでボールの総積 =  ループ回数に気が付いて実装できることがわかる。なお袋には最低でも2つボールが含まれることから袋の数も16以下とわかり上限をあげる必要もないとか考えた・・・☆　→ あとは掛け算をくり返し行うため、最後まで行って戻ってきたときにその先の情報を忘れて次へ進むことができたら便利だなと考えた。これは掛け算を途中で一切更新せず、引数の中で掛け算を行えば値が記憶されないことを利用して処理した。

➁ 再帰関数上限

sys.setcursionlimit()で制御できる再帰関数の上限であるが、☆で既述したようにループ宣言の個数だと思っていたのだが、どうやらループの回数みたい

![image](https://user-images.githubusercontent.com/109026838/190244593-0fb9e62c-381d-4536-b95f-1c6f67fc7975.png)

しかしながら提出コードでは上限を上げなかったのにもかかわらず、10^5回程度ループする処理も問題なく実行されACできた。よく調べたが結局何の回数なのかわからないままであるので、とりあえずループ回数を賄えるくらいの上限を設定することにしよう


③　別解

どのボールを使うか、itertools.productで直接求めてることが可能







# Union Find 勉強





# ☆ 177D Friends  diff 732

諦め

備考

➀ N人それぞれの友達集合を作成し、その友達の友達集合との差集合を追加していく処理を考えたが、nC2程度かかる場合もあるので間に合わない　→　ほかに打ち手もなく降参

➁ Union Find


 





# 2分探索 勉強➁ 二分法

# アルゴ式 2分法

# Q2-1 方程式を解く

備考

➀ 二分法

リスト内の挿入位置を調べるにはnp.searchsortedなどの二分探索が役立つが、対象がリストでない場合には使えない。

したがってこの問題では、方程式の近似解を求めるためのアルゴリズム二分法を使って解を求める




