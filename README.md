# 0829 

# Unlucky 7  diff 131

解答遷移  AC

問題把握 00:13  発想 00:00   base 04:30  デバック&提出 02:05

備考

➀ 8進数

整数Nの8進数文字列は f"{N:o}"で出力可能




# 185C Duodecim Ferra diff 374　

解答遷移 WA 諦め(再解答の必要はなし)

問題把握 01:42  発想 + base 08:18  計 21:14 諦め


備考

➀ scipy.special 整数型

![image](https://user-images.githubusercontent.com/109026838/187097939-c96a938b-fa12-4ad8-8ab6-90d48c2a0c79.png)

int(comb((L-1),11))としたためにL=200などの大きな値の処理が正確出来なかった。

3つだけWAが発生してコーナーケースを考えたが存在しないと結論付けた。そこで上限値でなにか問題が発生しているのかなと考えたはしたのだが、その場合はどうせ解けないなとcombの仕様を調べようともせずににすぐ諦めてしまった。仕様を知らなかったことは仕方ないが、この努力をできなかったことを大きく反省する。


# ABC171D Replacing    diff 498

解答遷移 AC

問題把握 01:13  発想 01:31  base 04:48  デバック&提出 05:12  計 12:46

備考

なし



# 258C Rotation  2回目   diff 419    類題 199C

解答遷移 AC

問題把握 01:22  発想 11:08  base 03:16  デバック&提出 01:04　計 16:52


備考

➀ 思考

クエリ1で本当に入替を行うのは無理だから疑似いれかえをしたいな →  最初のindex番号をキーに、要素をvalueにした辞書を作ることを考えたが、キーを変化させるにはループが必要になるからこれじゃだめだな。→ 結構時間をかけて考えた後、クエリ２で取り出す場所の方をいれかえを反映させた数字にすればよいこと気付いてACできた





# 187C 1-SAT   diff 207

解答遷移 AC

問題把握 02:01  発想 09:15  base 06:02  デバック&提出 12:24  計 29:43


備考

➀ 速度ボトルネック

題意読み取りミスが原因。Sを揃えてから存在確認の判定を必要があることになかなか気づかなかった。

また解法もナンセンス

そもそも調べる文字列が"!"つきか否か分類する必要がない。例えば red は red , !red を調べるのに対して、!red なら !red , !!red であるため、なにか特別な処理を施さなくても自然に異っていて条件で区別する必要がないことを読み取れななかった。



* この読み取りミスの原因は部分的な処理に頭を使ってしまうこと？

今回では!をうまく処理するためにpopがいけるかどうかみたいなことに9割思考を割いてしまうせいで、やらなければいけないことが曖昧なまま方針を進めたり、コードを書いてしまうことが原因かもしれない。速度ガ大切なため完全に整理してから進めるのは不可能だが、全体を俯瞰する姿勢をとる必要がありそう。



# 265C  Comma   diff 265

解答遷移 AC

問題把握 00:40  発想 05:44  base 05:44  デバック&提出 02:57  計 15:07  

備考

➀ 速度ボトルネック

N < 10^s における探索時の個数処理の正確さが不安で確認を慎重に行ったために作成時に時間がかかってしまった。N+1<=10^sなのだからどんなNであってもmin処理の結果が同じことが時間をかけないとわからなかった。


➁　別解(模範解答)

その数に何個のカンマがあるのかに注目する自分の解答とは異なり、その数に特定の位置のカンマが存在するかに注目することもできる。例えばN=7,777,777の場合、3-4桁目,6-7桁目のカンマは存在するが、9-10桁目,12-15桁目,18-19桁目のカンマは存在しない。よって+2のように考えることも可能。





# 0831 

# 176C Step  diff  72

解答遷移 AC

問題把握 00:21  base 04:21  デバック&提出 01:35  計 06:18

備考

なし


# 209C  Not Equal  diff 285 

解答遷移 AC

発想まで?  11:44   baseから提出まで? 05:23   計 17:07  (境界が曖昧)

備考

➀ 思考

素直に実装すると、Cの要素を前から探索して、その要素の値以下の数値を探索していくことになるがそれは無理だな。　→ 逆にどんな数値かを探索して、setで重複処理すればいけるか？ でも、Aが数値ではないので探索ができない  

Cの制約的に探索するのかと思ったが、思いつく限りの探索方法を講じても制約を突破できないので何か直接答え出力する方法がないか探してみる。 → sortして前から順に、i番目に(要素-i)の値をかけていく処理をすればよいことに気づいてAC


とても速い提出とはいえないが、プロセス自体は良いと思うので、あとは自分自身の思考処理がはやくなれば完璧





# 189C Mandarin Orange  diff 565

解答遷移  AC

問題把握 02:38  発想 18:44  base 03:30  デバック&提出 00:52  計 25:46

備考

➀思考

前から探索しても、区間を探索できないから組み合わえ使うか？ でも5.0 * 10^7で無理ではないが他のより高速な処理を探そう　→ 探索開始位置と終了位置を二重ループで操作するのはどうか？　これも結局同じか　

setならmin処理が速いか調べたりしながら、ここでようやく区間の始点終点を決めても取り出すのにO(l)かかるからこれじゃだめなことに気づく。

発想を変えてAの要素で探索しようとしたところ 5.0 * 10^7にはなるがこれで解答は一応できることがわかったので、ほかに案もないしダメもとで出したらACできた。


➁模範解答

よく考えたら区間をとりだす必要はなく、その区間での最小値さえわかればよいので自分が捨てた方針でACできる。ただしmin処理に注意

➁ pypy 

➀でも記述したが、5.0 * 10^7 ならpypyで通る






#  0901  

# 176B Multiple of 9     diff  51

解答遷移 AC

問題把握 00:45  base 01:06  デバック&提出 00:41  計 02:33

備考

なし


# 177B Substring     diff  193

解答遷移 AC

備考　

なし



# 166C Peak   diff 263

解答遷移 AC

計 24:21

備考

➀　思考と計算量

各展望台について隣接する展望台のリストを作ってその最大値をmaxで取得する場合、O(N^2)になるためこれではだめだなと思って、熟考し最大値のみを保有することでO(N)の解答を導くことができた。

しかし、却下した方針でも普通にACできた。これは、ある展望台については他全ての展望台と隣接することはあっても、隣接候補が2M個しかないために探索回数はO(N^2)ではなくO(2M)になるからだと思われる。




#  Alter Altar     diff  486

解答遷移 AC

問題把握  04:07  発想 24:27   提出まで 02:32  計  31:56


備考

➀ 思考

1,アルゴリズム理解 09:49  + 2,コードでどう実装するかの思考 15:27  の計24:27を発想段階で費やした。(少しコードも書いてはいるがほぼ思考時間)


とりあえずシミレーション。入替と色変えの効率を比べたりしながら、石の入れ替え位置候補が多すぎてこれを探索することは不可能だと感じ、操作完了時の石の状態に注目してみた。すると最も右の位置にある赤石と最も左の位置にある白石が...w...R...のように白 < 赤になっている場合にはまだ操作が必要で、そうでないなら操作完了になるなと気が付く　 1  → 白石と赤石の位置を調べあげ、初めて白 > 赤　になるindex回操作が必要である処理でAC 2




# 196B  Round Down   diff 39

解答遷移 AC

問題把握 00:13    提出まで 03:31   計 03:45   

備考

➀ 思考

floatで受け取って、math.floorすればいいや。→ sample3で、入力を受け取った時点で小数16桁付近から情報が落ちていることを確認。仕方なく文字列として受け取り前から "." まで探索し出力する方針でAC

割算演算の結果のみでなく、入力時点でも情報が落ちてしまうことに気を付ける




# 0902

# uNrEaDaBlE sTrInG   diff  23

解答遷移 AC

計 04:18

備考

➀ 小文字 / 大文字判定

文字列.islower() /  .isupper()にて文字列が全て小文字か大文字かを判定できる



# Unexpressed   diff 379

解答遷移 WA  WA  AC

問題把握 00:49   発想  02:49   base  03:40   初提出までのデバック  12:36   AC 08:17   計 28:12 +10:00


備考

➀　注意点

1, 重複処理

たとえば 16　のような 2^4　とも 4^2 とも表現できる数字のカウントを正確に行わなくてはいけない

2, break処理

a^2 > N となった場合、(a+1) ^2 >Nなので処理をうち切りたい。b=2のまま処理が終了したことを表すflagを使ってprintする処理を実装した場合、ループ回数が十分に大きくないと10^10の場合にprintされないことになる。詳しくはコード参照




# ☆ 226D Teleportation     diff 706

平行な場合にも同じ魔法であることを処理できず諦め

問題把握 04:14  発想 29:13  base 11:55  　計 1:04:32


備考

➀ 傾きと最大公約数

2点間の変化量を表す傾き dy/dxを素直に実装すると割算になって不便であることは　226C(0820) でも学んだが、dxとdyの最大公約数gによって(dx/g,dy/g)により、その傾きを代表するベクトルを表現できる。

なお、a,bの最大公約数はmath.gcd(a,b)にて O(log(max(a,b))で出力可能


➁ hash化　タプルとリスト

辞書のキーやsetの要素にリストは渡せないが、タプルなら可能


③ 解答補足

combinationsを使っ探索し結果を2倍する処理では正解できない。なぜなら傾きの絶対値が同じ2点であってもベクトルが違えば傾きが変化しsetにどちらも格納されることになってしまうからである



#  148C  Snack

解答遷移 AC

計 05:35

備考

➀　最小公倍数

a,bの最小公倍数は　a * b // gcd(a,b)  で求められる





# 224C Triangle? 2回目

解答遷移  RE ➁ / TLE ③ / AC ➀

計 27:15 + 10:00

備考

➀　最大公約数解法

226Dで傾きを最大公約数で解釈できるようになったので練習がてらこの問題を最大公約数を利用して解いてみた。この問題では選んだ3点において、同一直線状にあっても始点の決め方でベクトルの向きが変ってしまうこと、にさえ気を付ければこの解法でもACすることができた。

ただし模範解答の、傾き分母払い解法であれば逆ベクトルを考える必要がないためこちらの方が楽である。


➁scipy と pypy

pypypではnumpy 同様にscipyも扱えない。そのためこの問題をpypyで通したいなら、N* (N-1)* (N-2)//6とするしかない

③ 計算量

NC3 * log(max(dx,dy)) はx,y <= 10^9　により 10^8近くなる。そのためpythonで最大公約数解法は使えない



# 0903

# 048A A to Z String   diff 54

解答遷移  AC

計 01:59

備考

なし


# 053B A to Z String  diff 164

解答遷移  AC

計 07:33

備考

➀　解法

読み違えたままACしてしまったが、この問題ではZが来ても数をリセットするのではなく、最左のAの位置と最右のZの位置が分かればよい問題である




# 連結リスト Linked List 勉強

ノードのつながりを記憶するデータ構造。インスタンスにその前後のインスタンスを記憶させて、挿入をくりかえすことで一つの連結リストを作成する

・ LikedList インスタンス式

https://www.delftstack.com/ja/howto/python/linked-list-in-python/

ノードの挿入などの関数を持つ全体のクラスを作成し、これを操作してノードインスタンスを連結させる方法

・アルゴ式

https://algo-method.com/tasks/844/editorial

最初と最後のノードnilを作り、nilを目印にして連結する方法


・欠点

abc225(後述) に顕著であるが、特定の位置にアクセスすることができない。前から辿って見つける必要がある。

https://www.momoyama-usagi.com/entry/info-algo-list#i-2





# ☆ abc225D  Play Train   diff  778

方針がたたず諦め

備考

➀ 双方向連結リスト

上述した連結リストの考えで解答可能。ただし生成される連結リストが一つではない点、アクセスが不便な点からTrainクラスの連結でこの問題を解くことは難しい。

そこでリストのtrain番号に対応した場所にその電車の前にある電車と後ろにある電車の情報を格納したリストを格納することで操作1,2をO(1)で処理することができる。もしくは前の電車の情報と後ろの電車の情報をそれぞれ別のリストにわけて記憶することでも解答可能




# ☆ 181D Hachi    diff  600

解法がわからず諦め

備考

➀　思考

並び替えの探索は不可能なのでそれ以外の方針をとるべきだとは思ったものの、8進数や他の方針を考え始めて、しまいには8の倍数の判定方法を調べることもせずあきらめてしまった。

８の倍数を列挙して4の倍数の様に下2桁に注目して8の倍数以外もあるなと最初に気づき、そこでこの方針はだめだと打ち切ったことを引き釣り判定方法わからないと結論付けて調べようともしないこの姿勢がダメ


➁ 8の倍数

1000 = 125 * 8 であることに注目すると、例えば 5424 → 5* 1000^1  + 424 * 1000^0 より 424 が8の倍数であることと、5424が8の倍数であることの真偽は一致する




#  180A  box  

解答遷移 AC

備考

なし


#  180B Various distances   diff 129

解答遷移 AC

備考

なし



# ☆　211C  chokudai  diff 559

解答遷移 TLE 諦め

備考

➀ 思考

chokudaiを構成する8文字のそえぞれがSに出てくる場所さえわかれば、cから順に次の文字を二分探索すれば、例えば8文字すべてに10^5 /8 個登場するとしても 10^5 / 8 * 10g(10^5 / 8)^8 で間に合うと思った。

しかし実際に実装してみると次の文字の中でもある文字を動かす必要があり結局これではループが8重になりTLEすることに気づいた。

かなり時間を使ってようやくdpっぽく処理できるなと気づき導入。chokudaiリストと同じ形状のdpを作って、dp[n][m]を文字nの中のm番目のものを使ってchokudaiのnの文字までの組み方の数を表して、nのm番目とn+1のm`番目を比較してm<m`ならばdp[i+1][m`]+=dp[i][m]とすればよいと考えた。　→ しかしこれでは8つの文字それぞれにおいて前から順に探索が必要な点が解消されていないのでACできずTLEしてしまった


➁　模範解答

dp

Sに出てくるn番目の文字でchokudaiのある場所までを表現することができる総数に注目する。例えばn番目がkならn-1番目までで作ったoまでの文字列が新たにkまで構成できるようになるのでdp[n][kを表すindexl+=dp[n-1][kを表すindex]+dp[n-1][oを表すindex]  * が成り立つ

またcにおいては前の文字がなく、dp[n][cを表すindex]=dp[n-1][cを表すindex]+1となるが、すべての要素が1の-1列目をdpに追加すれば他の処理と同じく * 式で済む

また、実はdpでは直前の情報以外使用しないので、すべての情報を記憶する意味はない。よって9列の一次元リストを作成し、S[i]がchokudaiを構成するならばdp[S[i]の表すindex+1] = dp[S[i]を表すindex]として古い情報を更新してしまうことも可能




# 0905

# Changing Jewels   diff  413　　2回目

解答遷移  AC

計 09:47

備考

➀ dpで解答



# アルゴ式 dp基礎編

# 3-2 部分和問題

解答遷移 AC

計 25:00

備考

➀ 思考

2^100は探索できない。M以下の最大値を保存していてもW1+WN=Mだった場合などでMにならなくなるので途中の重さの情報を保存する必要があると気づく。→ そのためには0からM+1までの列を作ってdp[i][j]にはWiまでで重さjにできるかの真偽を格納すればよい


# ========================  データ損失 =====================================================

# 3-5  部分和問題応用

解答遷移 WA AC

計 59:04

備考
















# 2分探索 勉強➁ 二分法

# アルゴ式 2分法

# Q2-1 方程式を解く

備考

➀ 二分法

リスト内の挿入位置を調べるにはnp.searchsortedなどの二分探索が役立つが、対象がリストでない場合には使えない。

したがってこの問題では、方程式の近似解を求めるためのアルゴリズム二分法を使って解を求める




